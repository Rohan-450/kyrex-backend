import { EVENT_TYPES, MAX_CHECKPOINT, ZERO_CHECKPOINT, encodeCheckpoint, } from '../utils/checkpoint.js';
import { toLowerCase } from '../utils/lowercase.js';
import { hexToBigInt, hexToNumber } from "viem";
export const encodeBlock = ({ block, chainId, }) => {
    return {
        hash: block.hash,
        chainId,
        checkpoint: encodeCheckpoint({
            blockTimestamp: hexToNumber(block.timestamp),
            chainId: BigInt(chainId),
            blockNumber: hexToBigInt(block.number),
            transactionIndex: MAX_CHECKPOINT.transactionIndex,
            eventType: EVENT_TYPES.blocks,
            eventIndex: ZERO_CHECKPOINT.eventIndex,
        }),
        baseFeePerGas: block.baseFeePerGas
            ? hexToBigInt(block.baseFeePerGas)
            : null,
        difficulty: hexToBigInt(block.difficulty),
        number: hexToBigInt(block.number),
        timestamp: hexToBigInt(block.timestamp),
        extraData: block.extraData,
        gasLimit: hexToBigInt(block.gasLimit),
        gasUsed: hexToBigInt(block.gasUsed),
        logsBloom: block.logsBloom,
        miner: toLowerCase(block.miner),
        mixHash: block.mixHash ?? null,
        nonce: block.nonce ?? null,
        parentHash: block.parentHash,
        receiptsRoot: block.receiptsRoot,
        sha3Uncles: block.sha3Uncles ?? null,
        size: hexToBigInt(block.size),
        stateRoot: block.stateRoot,
        totalDifficulty: block.totalDifficulty
            ? hexToBigInt(block.totalDifficulty)
            : null,
        transactionsRoot: block.transactionsRoot,
    };
};
export const encodeLog = ({ log, block, chainId, }) => {
    return {
        id: `${log.blockHash}-${log.logIndex}`,
        chainId,
        checkpoint: block === undefined
            ? null
            : encodeCheckpoint({
                blockTimestamp: hexToNumber(block.timestamp),
                chainId: BigInt(chainId),
                blockNumber: hexToBigInt(log.blockNumber),
                transactionIndex: hexToBigInt(log.transactionIndex),
                eventType: EVENT_TYPES.logs,
                eventIndex: hexToBigInt(log.logIndex),
            }),
        blockHash: log.blockHash,
        blockNumber: hexToBigInt(log.blockNumber),
        logIndex: hexToNumber(log.logIndex),
        transactionHash: log.transactionHash,
        transactionIndex: hexToNumber(log.transactionIndex),
        address: toLowerCase(log.address),
        topic0: log.topics[0] ? log.topics[0] : null,
        topic1: log.topics[1] ? log.topics[1] : null,
        topic2: log.topics[2] ? log.topics[2] : null,
        topic3: log.topics[3] ? log.topics[3] : null,
        data: log.data,
    };
};
export const encodeTransaction = ({ transaction, block, chainId, }) => {
    return {
        hash: transaction.hash,
        checkpoint: encodeCheckpoint({
            blockTimestamp: hexToNumber(block.timestamp),
            chainId: BigInt(chainId),
            blockNumber: hexToBigInt(transaction.blockNumber),
            transactionIndex: hexToBigInt(transaction.transactionIndex),
            eventType: EVENT_TYPES.transactions,
            eventIndex: ZERO_CHECKPOINT.eventIndex,
        }),
        chainId,
        blockHash: transaction.blockHash,
        blockNumber: hexToBigInt(transaction.blockNumber),
        accessList: transaction.accessList
            ? JSON.stringify(transaction.accessList)
            : undefined,
        from: toLowerCase(transaction.from),
        gas: hexToBigInt(transaction.gas),
        gasPrice: transaction.gasPrice ? hexToBigInt(transaction.gasPrice) : null,
        input: transaction.input,
        maxFeePerGas: transaction.maxFeePerGas
            ? hexToBigInt(transaction.maxFeePerGas)
            : null,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
            ? hexToBigInt(transaction.maxPriorityFeePerGas)
            : null,
        nonce: hexToNumber(transaction.nonce),
        r: transaction.r ?? null,
        s: transaction.s ?? null,
        to: transaction.to ? toLowerCase(transaction.to) : null,
        transactionIndex: hexToNumber(transaction.transactionIndex),
        type: transaction.type ?? "0x0",
        value: hexToBigInt(transaction.value),
        v: transaction.v ? hexToBigInt(transaction.v) : null,
    };
};
export const encodeTransactionReceipt = ({ transactionReceipt, chainId, }) => {
    return {
        transactionHash: transactionReceipt.transactionHash,
        chainId,
        blockHash: transactionReceipt.blockHash,
        blockNumber: hexToBigInt(transactionReceipt.blockNumber),
        contractAddress: transactionReceipt.contractAddress
            ? toLowerCase(transactionReceipt.contractAddress)
            : null,
        cumulativeGasUsed: hexToBigInt(transactionReceipt.cumulativeGasUsed),
        effectiveGasPrice: hexToBigInt(transactionReceipt.effectiveGasPrice),
        from: toLowerCase(transactionReceipt.from),
        gasUsed: hexToBigInt(transactionReceipt.gasUsed),
        logsBloom: transactionReceipt.logsBloom,
        status: transactionReceipt.status,
        to: transactionReceipt.to ? toLowerCase(transactionReceipt.to) : null,
        transactionIndex: hexToNumber(transactionReceipt.transactionIndex),
        type: transactionReceipt.type,
    };
};
export function encodeTrace({ trace, block, transaction, chainId, }) {
    return {
        id: `${transaction.hash}-${trace.index}`,
        chainId,
        checkpoint: encodeCheckpoint({
            blockTimestamp: hexToNumber(block.timestamp),
            chainId: BigInt(chainId),
            blockNumber: hexToBigInt(block.number),
            transactionIndex: hexToBigInt(transaction.transactionIndex),
            eventType: EVENT_TYPES.traces,
            eventIndex: BigInt(trace.index),
        }),
        type: trace.type,
        transactionHash: transaction.hash,
        blockHash: block.hash,
        blockNumber: hexToBigInt(block.number),
        from: toLowerCase(trace.from),
        to: trace.to ? toLowerCase(trace.to) : null,
        gas: hexToBigInt(trace.gas),
        gasUsed: hexToBigInt(trace.gasUsed),
        input: trace.input,
        functionSelector: trace.input.slice(0, 10),
        output: trace.output ?? null,
        revertReason: trace.revertReason
            ? trace.revertReason.replace(/\0/g, "")
            : null,
        error: trace.error ? trace.error.replace(/\0/g, "") : null,
        value: trace.value ? hexToBigInt(trace.value) : null,
        index: trace.index,
        subcalls: trace.subcalls,
        isReverted: trace.error === undefined ? 0 : 1,
    };
}
//# sourceMappingURL=encoding.js.map