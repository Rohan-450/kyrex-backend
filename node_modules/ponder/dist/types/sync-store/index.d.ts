import type { Database } from '../database/index.js';
import type { Common } from '../internal/common.js';
import type { Factory, Filter, FilterWithoutBlocks, Fragment, RawEvent } from '../internal/types.js';
import type { LightBlock, SyncBlock, SyncLog, SyncTrace, SyncTransaction, SyncTransactionReceipt } from '../types/sync.js';
import type { Interval } from '../utils/interval.js';
import { type Address, type Hash } from "viem";
export type SyncStore = {
    insertIntervals(args: {
        intervals: {
            filter: FilterWithoutBlocks;
            interval: Interval;
        }[];
        chainId: number;
    }): Promise<void>;
    getIntervals(args: {
        filters: Filter[];
    }): Promise<Map<Filter, {
        fragment: Fragment;
        intervals: Interval[];
    }[]>>;
    getChildAddresses(args: {
        filter: Factory;
        limit?: number;
    }): Promise<Address[]>;
    filterChildAddresses(args: {
        filter: Factory;
        addresses: Address[];
    }): Promise<Set<Address>>;
    insertLogs(args: {
        logs: {
            log: SyncLog;
            block?: SyncBlock;
        }[];
        shouldUpdateCheckpoint: boolean;
        chainId: number;
    }): Promise<void>;
    insertBlocks(args: {
        blocks: SyncBlock[];
        chainId: number;
    }): Promise<void>;
    /** Return true if the block receipt is present in the database. */
    hasBlock(args: {
        hash: Hash;
    }): Promise<boolean>;
    insertTransactions(args: {
        transactions: {
            transaction: SyncTransaction;
            block: SyncBlock;
        }[];
        chainId: number;
    }): Promise<void>;
    /** Return true if the transaction is present in the database. */
    hasTransaction(args: {
        hash: Hash;
    }): Promise<boolean>;
    insertTransactionReceipts(args: {
        transactionReceipts: SyncTransactionReceipt[];
        chainId: number;
    }): Promise<void>;
    /** Return true if the transaction receipt is present in the database. */
    hasTransactionReceipt(args: {
        hash: Hash;
    }): Promise<boolean>;
    insertTraces(args: {
        traces: {
            trace: SyncTrace;
            block: SyncBlock;
            transaction: SyncTransaction;
        }[];
        chainId: number;
    }): Promise<void>;
    /** Returns an ordered list of events based on the `filters` and pagination arguments. */
    getEvents(args: {
        filters: Filter[];
        from: string;
        to: string;
        limit?: number;
    }): Promise<{
        events: RawEvent[];
        cursor: string;
    }>;
    insertRpcRequestResult(args: {
        request: string;
        chainId: number;
        blockNumber: bigint | undefined;
        result: string;
    }): Promise<void>;
    getRpcRequestResult(args: {
        request: string;
        chainId: number;
    }): Promise<string | undefined>;
    pruneRpcRequestResult(args: {
        blocks: Pick<LightBlock, "number">[];
        chainId: number;
    }): Promise<void>;
    pruneByChain(args: {
        chainId: number;
    }): Promise<void>;
};
export declare const createSyncStore: ({ common, database, }: {
    common: Common;
    database: Database;
}) => SyncStore;
//# sourceMappingURL=index.d.ts.map